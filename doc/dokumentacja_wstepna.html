<h1 class="Title">Techniki kompilacji</h1>
<h2 class="Subtitle">Dokumentacja wstepna projektu</h2>
<h2 class="Subtitle"><cite>System analizy sformalizowanych aktów prawnych.</cite></h2>
<h3 class="Author">Autor: <strong>Andrzej Fiedukowicz</strong></h3>
<h3 class="Author">Prowadz¹cy projekt: <strong>Piotr Gawkowski</strong></h3>
<div class="PageSeparator"></div>
<h1>Nieformalne sformu³owanie problemu</h1>
<p>Aplikacja ma za zadanie spe³niaæ nastêpuj¹ce funkcje:</p>
<p>
<ol>
	<li>Analizowaæ wprowadzone w ni¿ej wyspecyfikowanym jêzyku akty prawne.</li>	
	<li>Odpowiadaæ na pytania dotycz¹ce poszczególnych predykatów z mo¿liwoœci¹ dodania wiedzy spoza aktów prawnych.<li>	
</ol>
</p>

Przyk³adowe wejœcia ( << ) i wyjœcia ( >> ):
PRZYK£AD 1:
<< Domyslnie nie idzieDoWiezienia(). //lista argumentów dla "Domyœlnie" jest ignorowana
<< Domyœlnie nie jestGatunkuChronionego().
<< Jesli wytnieDrzewo(Kto, Drzewo) i maPonadDwadziesciaLat(Drzewo) to idzieDoWiezienia(Kto).
<< Jesli wytnieDrzewo(Kto, Drzewo) i jestGatunkuChronionego(Drzewo) to idzieDoWiezienia(Kto).
<< Jesli jestBaobabem(Drzewo) lub jestBukiem(drzewo) to jestGatunkuChronionego(Drzewo).
<< wytnieDrzewo(franek, buk).
<< wytnieDrzewo(jozek, sosna).
<< idzieDoWiezienia(jozek)?
>> NIE (Z DOMYŒLNEGO)
<< nie maPonadDwadziesciaLat(sosna).
<< idzieDoWiezienia(jozek)?
>> NIE
<< idzieDoWiezienia(franek)?
>> NIE (Z DOMYŒLNEGO)
<< jestBukiem(buk).
<< idzieDoWiezienia(franek)?
>> TAK
<< nie jestGatunkuChroniongo(buk).
>> SPRZECZNOŒÆ Z "Jesli jestBaobabem(Drzewo) lub jestBukiem(drzewo) to jestGatunkuChronionego(Drzewo).", PREDYKAT ZIGNOROWANY

PRZYK£AD 2:
//Konwencja relacji na pierwszej pozycji wyszczególniono osobê opisan¹ predykatem np. brat(A, B) tzn. ¿e A jest bratem B.
<< rodzenstwo(A, B) i mezczyzna(B) oznacza, ze brat(A, B).
<< rodzenstwo(A, B) i kobieta(B) oznacza, ze siostra(A, B).
<< rodzenstwo(A, B) oznacza, ze siostra(A, B) lub brat(A, B).
<< rodzenstwo(A, B) oznacza, ze rodzenstwo(B, A).
<< Jeœli dziecko(A, B) to rodzic(B, A).
<< Jeœli rodzic(A, B) i mezczyzna(A) to ojciec(A, B).
<< Jeœli rodzic(A, B) i kobieta(A) to matka(A, B).



Formalna specyfikacja jêzyka (EBNF):
WEJSCIE = ZDANIE | ZDANIE, WEJSCIE;
ZDANIE = IMPLIKACJA | ROWNOWAZNOSC | TWIERDZENIE | DOMYSLNY | PYTANIE;
IMPLIKACJA = 'Jesli ', ILOCZYN, ' to ', ILOCZYN, '.';
ROWNOWAZNOSC = ILOCZYN, ' oznacza, ze ', ILOCZYN
DOMYSLNY = 'Domyslnie ', ZDANIE_PROSTE;
TWIERDZENIE = ILOCZYN, '.';
PYTANIE = ILOCZYN, '?';
ILOCZYN = SUMA, ' i ', ILOCZYN | SUMA;
SUMA = ZDANIE_PROSTE, ' lub ', SUMA | ZDANIE_PROSTE;
ZDANIE_PROSTE = IDENTYFIKATOR, '(', ARGUMETNY, ')' 
				| 'nie ', ZDANIE_PROSTE 
				| IDENTYFIKATOR, '(', ')';
ARGUMENTY = ARGUMENT, ',', ARGUMENTY | ARGUMENT;
ARGUMENT = ZMIENNA | OBIEKT;
IDENTYFIKATOR = SLOWO_Z_MALEJ;
ZMIENNA = SLOWO_Z_WIELKIEJ;
OBIEKT = SLOWO_Z_MALEJ;
SLOWO_Z_MALEJ = MALA_LITERA, {LITERA};
SLOWO_Z_WIELKIEJ = WIELKA_LITERA, {LITERA};
LITERA = WIELKA_LITERA | MALA_LITERA;
WIELKA_LITERA = "A" | "B" | "C" | "D" | "E" | "F" | "G"
              | "H" | "I" | "J" | "K" | "L" | "M" | "N"
              | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
              | "V" | "W" | "X" | "Y" | "Z" ;
MALA_LITERA = "a" | "b" | "c" | "d" | "e" | "f" | "g"
              | "h" | "i" | "j" | "k" | "l" | "m" | "n"
              | "o" | "p" | "q" | "r" | "s" | "t" | "u"
              | "v" | "w" | "x" | "y" | "z" ;		

DRZEWO_WYRA¯ENIA - Sturktura drzewiasta z 0 - 2 dzieæmi dla ka¿dego wêz³a.
				   W liœciach znajduj¹ siê zdania proste, natomiast w pozosta³ych wêz³ach operatory logiczne (i, lub, nie).

PROCEDURA PYTANIE( ILOCZYN, FAKTY, ZNACZNIK_ZAPRZECZENIA = FALSE, STOS_PYTAN = pusty_stos )
0. Roz³ó¿ ILOCZYN na strukturê DRZEWO_WYRA¯ENIA

Opis algorytmu rozwi¹zuj¹cego problem (za³o¿enie braku sprzecznoœci w faktach):
PROCEDURA PYTANIE( PYTANIE, FAKTY, ZNACZNIK_ZAPRZECZENIA = FALSE, STOS_PYTAN = pusty_stos )
Argumenty:
  * PYTANIE - dowolne zdanie proste
  * FAKTY - zbiór faktów programu
  * STOS_PYTAN - uzywany do rekursji by zapamietac jakie pytanie doprowadzily nas do bierzacego
  * ZNACZNIK_ZAPRZECZENA - mo¿e byæ wyznaczany dynamicznie jeœli doszliœmy 
Zwraca
  * ODPOWIEDZ - { TRUE, FALSE, DONT_KNOW }
  
0. Jeœli PYTANIE jest na STOS_PYTAN to zwróæ DONT_KNOW.
1. ZnajdŸ formu³y zawieraj¹ce zdania proste wraz ze znacznikami zaprzeczenia  pasuj¹ce do zdania prostego PYTANIE i stwórz z nich listê L. (Wywo³aj procedurê L = ZNAJDZ_POWIAZANE(PYTANIE, FAKTY))
2. Dla ka¿dego elementu na liœcie L wyprowadŸ listê warunków LW do spe³anienia zdania prostego PYTANIE. (Wywo³aj procedurê LW(i) = ZNAJDZ_WARUNKI(PYTANIE, L(i)) dla ka¿dego L(i))
2a. Jeœli LW jest puste zwróæ negacjê wartoœci ZNACZNIK_ZAPRZECZENIA.
3. Dla ka¿dego elementu L(i) z listy L, dla ka¿dego zdania prostego LW(i)(j) ze struktury LW(i) wywo³aj PYTANIE(LW(i)(j), FAKTY, L(i).ZNACZNIK_ZAPRZECZENIA xor ZNACZNIK_ZAPRZECZENIA, STOS_PYTAN + L(i)).
   Podstaw wyniki zapytañ pod odpowiednie zdania proste w strukturze LW(i).
4. Dla ka¿dego elementu L(i) z listy L, dla ka¿dego zdania opisanego struktur¹ LW(i) wylicz jego wartoœæ logiczn¹ korzystaj¹c z obliczonych wartoœci zdañ prostych.
   Jeœli któregokolwiek ze zdañ LW(i) jest okreœlona to zwróæ tê wartoœæ.
   
PROCEDURA ZNAJDZ_POWIAZANE( PYTANIE, FAKTY )
0. Dla ka¿ego faktu F ze zbioru FAKTY wykonuj krok 1.
1. Znajdz wszystkie zdania proste w fakcie F. Dla ka¿dego zdania prostego Z wykonuj kroki 1.1 - 1.2
1.1. Jeœli zdanie proste ma inny identyfikator ni¿ PYTANIE to wróæ do 1.
1.2. WeŸ kolejne argumenty X - zdania PYTANIE i Y - zdania Z i wykonuj dla nich kroki 1.2.1 - 1.2.5
1.2.1. Jeœli X jest zmienn¹ i Y jest zmienn¹ kontynuuj podstawiaj¹c pod F_TMP fakt F.
1.2.2. Jeœli X jest zmienn¹ a Y jest obiektem wróæ do 1.
1.2.3. Jeœli X jest obiektem a Y jest zmienn¹ kontynuuj podstawiaj¹c pod F_TMP fakt F z podstawieniem X pod Y.
1.2.4. Jeœli X jest zmiennn¹ i Y jest zmienn¹, kontynuuj jeœli X równe jest Y podstawiaj¹c pod F_TMP fakt F.
1.2.5. Dodaj do listy L fakt F_TMP
2. Zwróæ listê L

PROCEDURA ZNAJDZ_WARUNKI( PYTANIE, FAKT )
0. Zapisz FAKT w formie drzewa typu DRZEWO_WYRA¯ENIA.
1. 