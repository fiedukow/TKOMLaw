<h1 class="Title">Techniki kompilacji</h1>
<h2 class="Subtitle">Dokumentacja wstepna projektu</h2>
<h2 class="Subtitle"><cite>System analizy sformalizowanych aktów prawnych.</cite></h2>
<h3 class="Author">Autor: <strong>Andrzej Fiedukowicz</strong></h3>
<h3 class="Author">Prowadzący projekt: <strong>Piotr Gawkowski</strong></h3>
<div class="PageSeparator"></div>
<h1>Nieformalne sformułowanie problemu</h1>
<p>Aplikacja ma za zadanie spełniać następujące funkcje:</p>
<p>
<ol>
	<li>Analizować wprowadzone w niżej wyspecyfikowanym języku akty prawne.</li>	
	<li>Odpowiadać na pytania dotyczące poszczególnych predykatów z możliwością dodania wiedzy spoza aktów prawnych.<li>	
</ol>
</p>

Przykładowe wejścia ( << ) i wyjścia ( >> ):
PRZYKŁAD 1:
<< Domyslnie nie idzieDoWiezienia(). //lista argumentów dla "Domyślnie" jest ignorowana
<< Domyślnie nie jestGatunkuChronionego().
<< Jesli wytnieDrzewo(Kto, Drzewo) i maPonadDwadziesciaLat(Drzewo) to idzieDoWiezienia(Kto).
<< Jesli wytnieDrzewo(Kto, Drzewo) i jestGatunkuChronionego(Drzewo) to idzieDoWiezienia(Kto).
<< Jesli jestBaobabem(Drzewo) lub jestBukiem(drzewo) to jestGatunkuChronionego(Drzewo).
<< wytnieDrzewo(franek, buk).
<< wytnieDrzewo(jozek, sosna).
<< idzieDoWiezienia(jozek)?
>> NIE (Z DOMYŚLNEGO)
<< nie maPonadDwadziesciaLat(sosna).
<< idzieDoWiezienia(jozek)?
>> NIE
<< idzieDoWiezienia(franek)?
>> NIE (Z DOMYŚLNEGO)
<< jestBukiem(buk).
<< idzieDoWiezienia(franek)?
>> TAK
<< nie jestGatunkuChroniongo(buk).
>> SPRZECZNOŚĆ Z "Jesli jestBaobabem(Drzewo) lub jestBukiem(drzewo) to jestGatunkuChronionego(Drzewo).", PREDYKAT ZIGNOROWANY

PRZYKŁAD 2:
//Konwencja relacji na pierwszej pozycji wyszczególniono osobę opisaną predykatem np. brat(A, B) tzn. że A jest bratem B.
<< rodzenstwo(A, B) i mezczyzna(B) oznacza, ze brat(A, B).
<< rodzenstwo(A, B) i kobieta(B) oznacza, ze siostra(A, B).
<< rodzenstwo(A, B) oznacza, ze siostra(A, B) lub brat(A, B).
<< rodzenstwo(A, B) oznacza, ze rodzenstwo(B, A).
<< Jeśli dziecko(A, B) to rodzic(B, A).
<< Jeśli rodzic(A, B) i mezczyzna(A) to ojciec(A, B).
<< Jeśli rodzic(A, B) i kobieta(A) to matka(A, B).



Formalna specyfikacja języka (EBNF):
WEJSCIE = ZDANIE | ZDANIE, WEJSCIE;
ZDANIE = IMPLIKACJA | ROWNOWAZNOSC | TWIERDZENIE | DOMYSLNY | PYTANIE;
IMPLIKACJA = 'Jesli ', ILOCZYN, ' to ', ILOCZYN, '.';
ROWNOWAZNOSC = ILOCZYN, ' oznacza, ze ', ILOCZYN
DOMYSLNY = 'Domyslnie ', ZDANIE_PROSTE;
TWIERDZENIE = ILOCZYN, '.';
PYTANIE = ILOCZYN, '?';
ILOCZYN = SUMA, ' i ', ILOCZYN | SUMA;
SUMA = ZDANIE_PROSTE, ' lub ', SUMA | ZDANIE_PROSTE;
ZDANIE_PROSTE = IDENTYFIKATOR, '(', ARGUMETNY, ')' 
				| 'nie ', ZDANIE_PROSTE 
				| IDENTYFIKATOR, '(', ')';
ARGUMENTY = ARGUMENT, ',', ARGUMENTY | ARGUMENT;
ARGUMENT = ZMIENNA | OBIEKT;
IDENTYFIKATOR = SLOWO_Z_MALEJ;
ZMIENNA = SLOWO_Z_WIELKIEJ;
OBIEKT = SLOWO_Z_MALEJ;
SLOWO_Z_MALEJ = MALA_LITERA, {LITERA};
SLOWO_Z_WIELKIEJ = WIELKA_LITERA, {LITERA};
LITERA = WIELKA_LITERA | MALA_LITERA;
WIELKA_LITERA = "A" | "B" | "C" | "D" | "E" | "F" | "G"
              | "H" | "I" | "J" | "K" | "L" | "M" | "N"
              | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
              | "V" | "W" | "X" | "Y" | "Z" ;
MALA_LITERA = "a" | "b" | "c" | "d" | "e" | "f" | "g"
              | "h" | "i" | "j" | "k" | "l" | "m" | "n"
              | "o" | "p" | "q" | "r" | "s" | "t" | "u"
              | "v" | "w" | "x" | "y" | "z" ;		

DRZEWO_WYRAŻENIA - Sturktura drzewiasta z 0 - 2 dziećmi dla każdego węzła.
				   W liściach znajdują się zdania proste, natomiast w pozostałych węzłach operatory logiczne (i, lub, nie).

PROCEDURA PYTANIE( ILOCZYN, FAKTY, ZNACZNIK_ZAPRZECZENIA = FALSE, STOS_PYTAN = pusty_stos )
0. Rozłóż ILOCZYN na strukturę DRZEWO_WYRAŻENIA

Opis algorytmu rozwiązującego problem (założenie braku sprzeczności w faktach):
PROCEDURA PYTANIE( PYTANIE, FAKTY, ZNACZNIK_ZAPRZECZENIA = FALSE, STOS_PYTAN = pusty_stos )
Argumenty:
  * PYTANIE - dowolne zdanie proste
  * FAKTY - zbiór faktów programu
  * STOS_PYTAN - uzywany do rekursji by zapamietac jakie pytanie doprowadzily nas do bierzacego
  * ZNACZNIK_ZAPRZECZENA - może być wyznaczany dynamicznie jeśli doszliśmy 
Zwraca
  * ODPOWIEDZ - { TRUE, FALSE, DONT_KNOW }
  
0. Jeśli PYTANIE jest na STOS_PYTAN to zwróć DONT_KNOW.
1. Znajdź formuły zawierające zdania proste wraz ze znacznikami zaprzeczenia  pasujące do zdania prostego PYTANIE i stwórz z nich listę L. (Wywołaj procedurę L = ZNAJDZ_POWIAZANE(PYTANIE, FAKTY))
2. Dla każdego elementu na liście L wyprowadź listę warunków LW do spełanienia zdania prostego PYTANIE. (Wywołaj procedurę LW(i) = ZNAJDZ_WARUNKI(PYTANIE, L(i)) dla każdego L(i))
2a. Jeśli LW jest puste zwróć negację wartości ZNACZNIK_ZAPRZECZENIA.
3. Dla każdego elementu L(i) z listy L, dla każdego zdania prostego LW(i)(j) ze struktury LW(i) wywołaj PYTANIE(LW(i)(j), FAKTY, L(i).ZNACZNIK_ZAPRZECZENIA xor ZNACZNIK_ZAPRZECZENIA, STOS_PYTAN + L(i)).
   Podstaw wyniki zapytań pod odpowiednie zdania proste w strukturze LW(i).
4. Dla każdego elementu L(i) z listy L, dla każdego zdania opisanego strukturą LW(i) wylicz jego wartość logiczną korzystając z obliczonych wartości zdań prostych.
   Jeśli któregokolwiek ze zdań LW(i) jest określona to zwróć tę wartość.
   
PROCEDURA ZNAJDZ_POWIAZANE( PYTANIE, FAKTY )
0. Dla każego faktu F ze zbioru FAKTY wykonuj krok 1.
1. Znajdz wszystkie zdania proste w fakcie F. Dla każdego zdania prostego Z wykonuj kroki 1.1 - 1.2
1.1. Jeśli zdanie proste ma inny identyfikator niż PYTANIE to wróć do 1.
1.2. Weź kolejne argumenty X - zdania PYTANIE i Y - zdania Z i wykonuj dla nich kroki 1.2.1 - 1.2.5
1.2.1. Jeśli X jest zmienną i Y jest zmienną kontynuuj podstawiając pod F_TMP fakt F.
1.2.2. Jeśli X jest zmienną a Y jest obiektem wróć do 1.
1.2.3. Jeśli X jest obiektem a Y jest zmienną kontynuuj podstawiając pod F_TMP fakt F z podstawieniem X pod Y.
1.2.4. Jeśli X jest zmiennną i Y jest zmienną, kontynuuj jeśli X równe jest Y podstawiając pod F_TMP fakt F.
1.2.5. Dodaj do listy L fakt F_TMP
2. Zwróć listę L

PROCEDURA ZNAJDZ_WARUNKI( PYTANIE, FAKT )
0. Zapisz FAKT w formie drzewa typu DRZEWO_WYRAŻENIA.
1. 